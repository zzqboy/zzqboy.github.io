{"meta":{"title":"zzqboy","subtitle":null,"description":null,"author":"zzqboy","url":"http://zzqboy.github.io"},"pages":[{"title":"categories","date":"2019-03-23T03:22:03.000Z","updated":"2019-03-23T03:22:27.543Z","comments":true,"path":"categories/index.html","permalink":"http://zzqboy.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-03-23T03:40:56.000Z","updated":"2019-03-23T03:42:25.479Z","comments":true,"path":"friends/index.html","permalink":"http://zzqboy.github.io/friends/index.html","excerpt":"","text":""},{"title":"我是谁？","date":"2019-03-23T03:23:20.000Z","updated":"2019-04-07T13:08:30.989Z","comments":true,"path":"about/index.html","permalink":"http://zzqboy.github.io/about/index.html","excerpt":"","text":"介绍毕业于华师大，高考的时候以为自己会成为一个老师之类的，结果报了通信工程系，意外的做了一个游戏工程师，现在每天在修bug中的痛苦中度过….熬夜成瘾(,,•﹏•,,) 爱好运动，电影，动漫，路边摊的小吃 个人项目自己平时学习的一些代码，欢迎交流 《统计学习方法》的python实现书作者是李航博士，这是大四实习时写的，那些AI、数据挖掘的基础书。 欢迎做个朋友Email : ziquanzheng@foxmail.comQQ : 1163802968"},{"title":"tags","date":"2019-03-23T03:20:48.000Z","updated":"2019-03-23T03:21:34.592Z","comments":true,"path":"tags/index.html","permalink":"http://zzqboy.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"浅析python排序算法timsort","slug":"浅析python排序算法timsort","date":"2019-04-09T14:41:04.000Z","updated":"2019-04-09T14:53:04.132Z","comments":true,"path":"2019/04/09/浅析python排序算法timsort/","link":"","permalink":"http://zzqboy.github.io/2019/04/09/浅析python排序算法timsort/","excerpt":"","text":"介绍timsort结合了插入排序和合并排序，主要是考虑到了，把每段有规律的数据分块，块的长度一开始计算好。然后有的数据块长度不足时使用插入补充。最后合并所有数据块。所以整个算法就是数据越规律，性能越高，整体性能甚至超过了快排： 过程定义 minrun 块长度 N 数组长度 确定minrunminrun根据输入数组的长度计算，因为块的长度影响最后合并的次数，如果块长度太短那么合并次数过多；太长那么要把每个块长度凑齐，插入排序的操作又太多。力求最后合并的次数是2的幂或略小于。123456789int GetMinrun(int n) &#123; int r = 0; while (n &gt;= 64) &#123; r |= n &amp; 1; n &gt;&gt;= 1; &#125; return n + r; &#125; 上面的公式说明：当N&lt;64的时候，minrun=N；当N&gt;=64；minrun与N最低6位有关 分块开始扫描，把有序的元素存入当前的run（块），如果这时候run长度小于minrun，那么直接添加后面缺的元素，知道长度达到minrun，这个时候后面的元素就不一定有序的，那么这个块需要进行插入排序。当然如果数据一直有序，那么run的长度就会比minrun大 ex:1 2 3 4 2 ….N = b10000 011111, minrun=5。run=[1, 2, 3, 4]，还是有序的。但是再加上2就不是有序，这个时候需要插入排序，变成[1, 2, 2, 3, 4] 合并依次把run压进栈，然后判断下面的两个条件是否满足： X &gt; Y + Z Y &gt; Z如果有一个不满足，那么找出X和Z中比较小的一个，和Y合并。直到满足了条件或者所有数据都排好序。（X、Y、Z表示run的size） (想象一个理想的例子：有一个128、64、32、16、8、4、2和2的运行（让我们暂时忘记运行大小≥minrun的要求）。在这种情况下，在最后两次运行不满足之前不会有任何合并，然后将执行七个完全平衡的合并。) 测试12345678910111213141516171819#coding:utf-8#现在项目排行榜有300人，假设服务器已经排好序，模拟下实时有个角色的数据变了，直接删除-添加-排序的耗时是多少import timeitimport randomrank_list = [i for i in range(300)]def resort(): index = value = random.randint(0, 299) rank_list.pop(index) rank_list.append(value) rank_list.sort() # print rank_listif __name__ == \"__main__\": print timeit.repeat(\"resort()\", setup=\"from __main__ import resort\", number=10000, repeat=3) print timeit.repeat(\"resort()\", setup=\"from __main__ import resort\", number=100000, repeat=3) print timeit.repeat(\"resort()\", setup=\"from __main__ import resort\", number=1000000, repeat=3) 结果：[0.07372325937786056, 0.07182481873564303, 0.07235884537346904][0.7830219300524532, 0.7451907132607314, 0.735450580565536][7.420490329467173, 7.352885764485594, 7.402370308503823] (这说明只要先排序了排行榜，那么1s的刷新可以达到10w次) 参考知乎上的问答一个比较简单的python实现本文的翻译原文参考","categories":[{"name":"技术","slug":"技术","permalink":"http://zzqboy.github.io/categories/技术/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://zzqboy.github.io/tags/algorithm/"},{"name":"python","slug":"python","permalink":"http://zzqboy.github.io/tags/python/"}]},{"title":"多线程与数据库","slug":"多线程与数据库","date":"2019-04-07T09:39:43.000Z","updated":"2019-04-09T14:41:31.545Z","comments":true,"path":"2019/04/07/多线程与数据库/","link":"","permalink":"http://zzqboy.github.io/2019/04/07/多线程与数据库/","excerpt":"前言上周写了一个多线程访问数据库的库，在听到隔壁工作室的项目是即时访问数据库后，出于对效率的好奇，打算在这里总结下。","text":"前言上周写了一个多线程访问数据库的库，在听到隔壁工作室的项目是即时访问数据库后，出于对效率的好奇，打算在这里总结下。 介绍本文用的是c++11的thread库，但是大多数的库用起来的差不多，能达到目的就可以。数据库用的mysql，并且是自带的c++api。源码在这里：数据库以及测试代码：测试 设计遵循了大部分的设计，即有一个工作队列，然后一开始设置好线程数，然后这几个线程就以队列为核心开始工作。 在增加任务的时候，也支持增加自定义的参数，这里用到是std::bind的特性。大概是这样用的12auto fun = std::bind(test_db::task_fun, placeholders::_1, is_sleep);this-&gt;db_work-&gt;add_task(fun); 只要最后的test_db::task_fun符合声明，那么这里可以像脚本一样传入不定长的参数。 再来看看task_fun:12345678910111213141516void test_db::task_fun(DBWork* db_work, bool is_sleep)&#123; DataBase* db = db_work-&gt;get_database(\"rpg\"); int col_n = 0; char** row; DATA_RESULT result = NULL; db-&gt;execute(\"select * from role;\", col_n, result); while (row = GET_RESULT_ROW(result)) &#123; //printf(\"%s\\n\", row[0]); &#125; if (is_sleep) &#123; Sleep(10); &#125;&#125; 这其实就是一个有待多线程去执行的函数，通过唯一参数db_work来执行数据库的操作，sleep是模仿了执行数据库命令后的其余逻辑。如果说前者是io密集，那么后者就是cpu密集。看来这里的设计变成了一个综合的问题。下面的是单线程的版本:123456789101112131415void test_db::test(bool is_sleep)&#123; int col_n = 0; char** row; DATA_RESULT result = NULL; this-&gt;db-&gt;execute(\"select * from role;\", col_n, result); while (row = GET_RESULT_ROW(result)) &#123; //printf(\"%s\\n\", row[0]); &#125; if (is_sleep) &#123; Sleep(10); &#125;&#125; 效率那么这样一个设计到时是改善了多少呢，这需要测试数据。这里分为有无sleep，也就是探究：单一执行mysql命令，多线程对数据库有帮助否，还是说数据库在io密集上不存在问题 参数说明： sleep:是否增加延时 multi-thread:是否多线程 count:次数 time:结果(ps:线程数都是12，和cpu核心一样) 编号 sleep multi-thread count time(毫秒) 1 yes yes 100 89 2 yes yes 1000 914 3 yes yes 5000 4572 4 yes no 100 1010 5 yes no 1000 11003 6 yes no 5000 55041 7 no no 100 25 8 no no 1000 273 9 no no 5000 1382 10 no no 100 33 11 no no 1000 293 12 no no 5000 1459 总结可以看到，当数据库的命令和上面一样简单的时候，多线程和单线程对于数据库部分的效率差不多。但是如果命令比较复杂，并且数据库设计不合理等原因导致数据库执行比较慢，达到sleep的效果的话就会增加效率。PS:（一句话，也就是看mysql语句的执行效率，也说明这种设计起码不会降低效率）","categories":[{"name":"技术","slug":"技术","permalink":"http://zzqboy.github.io/categories/技术/"}],"tags":[{"name":"thread","slug":"thread","permalink":"http://zzqboy.github.io/tags/thread/"},{"name":"mysql","slug":"mysql","permalink":"http://zzqboy.github.io/tags/mysql/"}]},{"title":"web的原理","slug":"web的原理","date":"2019-03-23T14:42:10.000Z","updated":"2019-04-07T09:51:31.901Z","comments":true,"path":"2019/03/23/web的原理/","link":"","permalink":"http://zzqboy.github.io/2019/03/23/web的原理/","excerpt":"介绍http协议可以说是最常用的一种网络协议，但是也很容易忽略了他的原理。还记得“在浏览器上打开一个网页请求，请你说出这背后的原理”这样的面试题吗？这一切在读《HTTP权威指南》后就可以了如指掌了。本文在简述原理后给出一个文中的栗子…","text":"介绍http协议可以说是最常用的一种网络协议，但是也很容易忽略了他的原理。还记得“在浏览器上打开一个网页请求，请你说出这背后的原理”这样的面试题吗？这一切在读《HTTP权威指南》后就可以了如指掌了。本文在简述原理后给出一个文中的栗子… 原理当我们发出一个get请求的时候，http server大概发生了下面几个步骤： 接受客户端请求 接受请求报文 处理请求 对资源的映射和访问 构建响应 发送响应 记录日志 这一切看来非常像游戏中一条协议的处理，下面详细讲这几个 请求http的请求的本质是tcp，自然会先建立tcp连接，那么server会在接受连接后，等待报文的到达。 报文解析报文的过程：由图可知，当数据没有接受完是不能进行解析报文的。 每行的CRLF和Content-length就是用来判断是否接受完 处理在解析报文后，就知道浏览器想让server干嘛了，就可以对应做出各种响应。(GET、POST、PUT、Delete、HEAD、Options) 响应报文通常包括:(主要还是看协议) Content-Type描述了是哪个MIME类型 Content-Length 主体内容 MIME的类型 不过也有可能是重定向的响应，响应码为3XX，不是最终的响应 发送server在发送完报文后，会关闭非持久的连接，对于持久连接是不会关闭的。 echo server文中有个perl的echo server，这里用python重现 1234567891011121314151617181920212223242526272829303132333435#coding:utf-8import socketimport tracebackdef star_server(): s_socket = socket.socket() s_socket.bind((\"127.0.0.1\", 80)) s_socket.listen(5) print \"echo server at 80\" conn, address = None, None while not conn: conn, address = s_socket.accept() recv_chunk = conn.recv(1024) recv_data = recv_chunk print \"------------------------------\" print recv_data print \"from\", address print \"------------------------------\" path = recv_data.split()[1] if path == \"/\": echo_content = raw_input(\"echo:\\n\") try: response = \"HTTP/1.1 200 OK\\r\\nConnection:close\\r\\nContent-type:text-plain\\r\\n\\r\\n\" response = response + echo_content conn.sendall(bytes(response)) except Exception, e: traceback.print_exc() conn.close() conn, address = None, Nonestar_server()","categories":[{"name":"技术","slug":"技术","permalink":"http://zzqboy.github.io/categories/技术/"}],"tags":[{"name":"http","slug":"http","permalink":"http://zzqboy.github.io/tags/http/"}]},{"title":"改善A星路径的猜想","slug":"改善A星路径的猜想","date":"2018-12-15T16:06:29.000Z","updated":"2019-03-23T03:31:15.340Z","comments":true,"path":"2018/12/16/改善A星路径的猜想/","link":"","permalink":"http://zzqboy.github.io/2018/12/16/改善A星路径的猜想/","excerpt":"问题如果周围都是可以寻路的点 并且是十字寻路，那么广度搜索和A*寻路的路径完全不一样 广度搜索都是一条笔直的线 A* 则是曲曲折折","text":"问题如果周围都是可以寻路的点 并且是十字寻路，那么广度搜索和A*寻路的路径完全不一样 广度搜索都是一条笔直的线 A* 则是曲曲折折 猜想在遍历一个点的4个方向的时候，如果最小分数有多个点，那么优先选择上次方向相同的点。如果只有一个点，那么只能强制选为下一个点，并且方向要改变。这样做后还是只能稍微改善下，不能完全解决，原因是分数小的点就是A星的核心，分数只要不一样就会一直改变方向 验证改善后： 结论如果一直强制一个方向也不是不可以，但会有下面两个问题： 强制不用A*算出的点，还能找到终点吗 这样会增加寻路复杂度感觉第一步就是强制设置为h函数的分数为0，那么永远在4个方向上选中一个点，但是这样就会退化成广度搜索了，毫无意义","categories":[{"name":"技术","slug":"技术","permalink":"http://zzqboy.github.io/categories/技术/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://zzqboy.github.io/tags/algorithm/"}]},{"title":"lua中面向对象","slug":"lua中面向对象","date":"2018-06-17T15:24:20.000Z","updated":"2019-03-23T03:31:12.124Z","comments":true,"path":"2018/06/17/lua中面向对象/","link":"","permalink":"http://zzqboy.github.io/2018/06/17/lua中面向对象/","excerpt":"pil实现方法要点：self语法糖、setmatetable元表、index方法提到了如何用__index方法来实现类和继承，让lua也具备面向对象的特性","text":"pil实现方法要点：self语法糖、setmatetable元表、index方法提到了如何用__index方法来实现类和继承，让lua也具备面向对象的特性 Account.lua123456789101112module(\"Account\", package.seeall)function Account:new(o) o = o or &#123;&#125; setmetatable(o, self) self.__index = self return oendfunction Account:deposit() print(\"account deposit\")end 这个机制的意思就是在创建一个新table的时候，把元类设为Account，在Account查找没有的方法12a = Account:new&#123;balance = 0&#125;a:deposit(100) -- 等价于 getmetatable(a).__index.deposit(a, 100) 实际上我们编写类的时候习惯把每个类划分为文件，如何用module结合上面的做法呢？这里写另外继承account的specialaccount类 SpecialAccount.lua12345678910module(\"SpecialAccount\", package.seeall)require(\"Account\")-- 继承自Account_G.SpecialAccount = Account:new()--定义基类没有的方法function SpecialAccount:getLimit() print(\"SpecialAccount getLimit\")end 注意上面的第5行代码，为什么不是书中的SpecialAccount = Account:new()？因为我们用module的时候已经默认引入了SpecialAccount，如果用这种做法，那么相当于增加了另外的变量，那么下面的代码就会报错 attempt to call method ‘new’ (a nil value) test.lua123456789require \"Account\"require \"SpecialAccount\"a = Account:new()a.deposit()s = SpecialAccount:new()s.deposit()s.getLimit() 原因在于module(“SpecialAccount”, package.seeall)相当于下面的代码12345local modname = \"SpecialAccount\"local M = &#123;&#125;_G[modname] = Mpackage.loaded[modname] = Msetfenv(1, M) 当SpecialAccount = Account:new()的时候，其实相当于1_G[\"SpecialAccount\"].SpecialAccount = Account:new() 这样在require “SpecialAccount”自然就找不到内嵌的new按照上面的写法就可以自然玩起面向对象了，附上代码https://github.com/zzqboy/misc/tree/master/lua_oo","categories":[{"name":"技术","slug":"技术","permalink":"http://zzqboy.github.io/categories/技术/"}],"tags":[{"name":"lua","slug":"lua","permalink":"http://zzqboy.github.io/tags/lua/"}]},{"title":"ksum问题","slug":"ksum问题","date":"2018-06-09T15:28:00.000Z","updated":"2019-03-23T03:31:03.716Z","comments":true,"path":"2018/06/09/ksum问题/","link":"","permalink":"http://zzqboy.github.io/2018/06/09/ksum问题/","excerpt":"","text":"问题1234567Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] 解决方案此前还有2sum问题，那么可以把这个问题扩展为k-sum对于找出3个数，我们可以先固定一个数，在剩下的数里面去找到两个，那么复杂度就是n^2，这太高了，有没有可能不用暴力解决。答案是肯定的，因为最终的和是知道的，那么我们固定了一个数，就可以根据其他两个数来判断是如何移动，达到线性搜索。前提是排好序 同理 4sum可以固定两个数，再去找剩余的两个数… 代码","categories":[{"name":"技术","slug":"技术","permalink":"http://zzqboy.github.io/categories/技术/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zzqboy.github.io/tags/leetcode/"}]},{"title":"erlang gb_tree平衡树做排行","slug":"erlang-gb-tree平衡树做排行","date":"2018-03-14T15:30:53.000Z","updated":"2019-03-23T03:31:09.036Z","comments":true,"path":"2018/03/14/erlang-gb-tree平衡树做排行/","link":"","permalink":"http://zzqboy.github.io/2018/03/14/erlang-gb-tree平衡树做排行/","excerpt":"介绍平衡树简称AVL，出名的有红黑树，这里介绍一下erlang中gb_tree的实现gb_tree的原理比红黑树简单，没有过多的旋转跳跃闭着眼，是一种叫AA树的结构（Arne Andersson’s General Balanced Trees），有兴趣看这篇论文：传送门","text":"介绍平衡树简称AVL，出名的有红黑树，这里介绍一下erlang中gb_tree的实现gb_tree的原理比红黑树简单，没有过多的旋转跳跃闭着眼，是一种叫AA树的结构（Arne Andersson’s General Balanced Trees），有兴趣看这篇论文：传送门 结构{Size, Tree}是整个结构体，Tree的定义又是{Key, Value, Smaller, Bigger} | nil初始化直接返回{0, nil} 插入123insert(Key, Val, &#123;S, T&#125;) when is_integer(S) -&gt; S1 = S+1, &#123;S1, insert_1(Key, Val, T, ?pow(S1, ?p))&#125;. % 给size+1，insert_1返回新的结构 insert_1又是如何找到要插入的位置，且做平衡的?1234567891011121314151617181920% 由于对称性，这里讲插入左子树的情况就行insert_1(Key, Value, &#123;Key1, V, Smaller, Bigger&#125;, S) when Key &lt; Key1 -&gt; % 要插入的key比目前节点的key小 case insert_1(Key, Value, Smaller, ?div2(S)) of % 递归，在目前节点的左子树继续查找，当Smaller为nil的时候返回下面两种情况 % T1 就是已经更新好的左子树 &#123;T1, H1, S1&#125; -&gt; T = &#123;Key1, V, T1, Bigger&#125;, &#123;H2, S2&#125; = count(Bigger), H = ?mul2(erlang:max(H1, H2)), %% 每层都会被调用一次 SS = S1 + S2 + 1, P = ?pow(SS, ?p), if H &gt; P -&gt; % 满足这个条件就重新平衡 balance(T, SS); true -&gt; &#123;T, H, SS&#125; end; T1 -&gt; &#123;Key1, V, T1, Bigger&#125; % 结果--节点和右子树均没改变，T1改变 end; 平衡也就是上面的balance(T, SS),这里什么时候会被执行呢？看一下下面代码123%% 是的insert_1的&#123;T1，H1， S1&#125;分支被执行insert_1(Key, Value, nil, S) when S =:= 0 -&gt; &#123;&#123;Key, Value, nil, nil&#125;, 1, 1&#125;; 看看官方的说明也就是说 13行的H&gt;P就是重新进行平衡的时候了，而平衡的操作也很简单，看下代码，就是按顺序填满一棵树123456789101112balance_list_1(L, S) when S &gt; 1 -&gt; Sm = S - 1, S2 = Sm div 2, S1 = Sm - S2, &#123;T1, [&#123;K, V&#125; | L1]&#125; = balance_list_1(L, S1), &#123;T2, L2&#125; = balance_list_1(L1, S2), T = &#123;K, V, T1, T2&#125;, &#123;T, L2&#125;;balance_list_1([&#123;Key, Val&#125; | L], 1) -&gt; &#123;&#123;Key, Val, nil, nil&#125;, L&#125;;balance_list_1(L, 0) -&gt; &#123;nil, L&#125;. 删除删除比插入是更简单了，找到对应的结点，然后从结点的右子树里找到一个最小的代替当前的点12345678910111213141516delete_1(Key, &#123;Key1, Value, Smaller, Larger&#125;) when Key &lt; Key1 -&gt; Smaller1 = delete_1(Key, Smaller), &#123;Key1, Value, Smaller1, Larger&#125;;delete_1(Key, &#123;Key1, Value, Smaller, Bigger&#125;) when Key &gt; Key1 -&gt; Bigger1 = delete_1(Key, Bigger), &#123;Key1, Value, Smaller, Bigger1&#125;;delete_1(_, &#123;_, _, Smaller, Larger&#125;) -&gt; merge(Smaller, Larger).merge(Smaller, nil) -&gt; Smaller;merge(nil, Larger) -&gt; Larger;merge(Smaller, Larger) -&gt; &#123;Key, Value, Larger1&#125; = take_smallest1(Larger), &#123;Key, Value, Smaller, Larger1&#125;. 可以看到整棵树没有旋转等复杂操作，但是仍是一个效率比lists高的二叉树 排行榜如果是上面实现的数据结构，那么排行榜是实时的，且各个操作效率比内置的List还快，我之前写的版本就是这个改的。只是有的地方需要改变一下，大概有下面几点 因为无法知道以后的需求，可以加入一个cmp函数自定义排序顺序查找前几名的时候，因为查找一个可以二分法，前几名同样也可以用二分法获取当某个榜上的玩家数据更新的时候，需要从树里删除再重新插入，这样才能保持有序其他的可以看看 https://cloud.tencent.com/developer/article/1006610","categories":[{"name":"技术","slug":"技术","permalink":"http://zzqboy.github.io/categories/技术/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://zzqboy.github.io/tags/algorithm/"}]}]}