{"meta":{"title":"啊权的碎碎念","subtitle":null,"description":null,"author":"zzqboy","url":"http://zzqboy.github.io"},"pages":[],"posts":[{"title":"改善A星路径的猜想","slug":"改善A星路径的猜想","date":"2018-12-15T16:06:29.000Z","updated":"2019-01-18T15:40:04.310Z","comments":true,"path":"2018/12/16/改善A星路径的猜想/","link":"","permalink":"http://zzqboy.github.io/2018/12/16/改善A星路径的猜想/","excerpt":"","text":"问题如果周围都是可以寻路的点 并且是十字寻路，那么广度搜索和A*寻路的路径完全不一样 广度搜索都是一条笔直的线 A* 则是曲曲折折 猜想在遍历一个点的4个方向的时候，如果最小分数有多个点，那么优先选择上次方向相同的点。如果只有一个点，那么只能强制选为下一个点，并且方向要改变。这样做后还是只能稍微改善下，不能完全解决，原因是分数小的点就是A星的核心，分数只要不一样就会一直改变方向 验证改善后： 结论如果一直强制一个方向也不是不可以，但会有下面两个问题： 强制不用A*算出的点，还能找到终点吗 这样会增加寻路复杂度感觉第一步就是强制设置为h函数的分数为0，那么永远在4个方向上选中一个点，但是这样就会退化成广度搜索了，毫无意义","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://zzqboy.github.io/tags/algorithm/"}]},{"title":"lua中面向对象","slug":"lua中面向对象","date":"2018-06-17T15:24:20.000Z","updated":"2019-01-18T15:42:35.593Z","comments":true,"path":"2018/06/17/lua中面向对象/","link":"","permalink":"http://zzqboy.github.io/2018/06/17/lua中面向对象/","excerpt":"","text":"pil实现方法要点：self语法糖、setmatetable元表、index方法提到了如何用__index方法来实现类和继承，让lua也具备面向对象的特性 Account.lua123456789101112module(\"Account\", package.seeall)function Account:new(o) o = o or &#123;&#125; setmetatable(o, self) self.__index = self return oendfunction Account:deposit() print(\"account deposit\")end 这个机制的意思就是在创建一个新table的时候，把元类设为Account，在Account查找没有的方法12a = Account:new&#123;balance = 0&#125;a:deposit(100) -- 等价于 getmetatable(a).__index.deposit(a, 100) 实际上我们编写类的时候习惯把每个类划分为文件，如何用module结合上面的做法呢？这里写另外继承account的specialaccount类 SpecialAccount.lua12345678910module(\"SpecialAccount\", package.seeall)require(\"Account\")-- 继承自Account_G.SpecialAccount = Account:new()--定义基类没有的方法function SpecialAccount:getLimit() print(\"SpecialAccount getLimit\")end 注意上面的第5行代码，为什么不是书中的SpecialAccount = Account:new()？因为我们用module的时候已经默认引入了SpecialAccount，如果用这种做法，那么相当于增加了另外的变量，那么下面的代码就会报错 attempt to call method ‘new’ (a nil value) test.lua123456789require \"Account\"require \"SpecialAccount\"a = Account:new()a.deposit()s = SpecialAccount:new()s.deposit()s.getLimit() 原因在于module(“SpecialAccount”, package.seeall)相当于下面的代码12345local modname = \"SpecialAccount\"local M = &#123;&#125;_G[modname] = Mpackage.loaded[modname] = Msetfenv(1, M) 当SpecialAccount = Account:new()的时候，其实相当于1_G[\"SpecialAccount\"].SpecialAccount = Account:new() 这样在require “SpecialAccount”自然就找不到内嵌的new按照上面的写法就可以自然玩起面向对象了，附上代码https://github.com/zzqboy/misc/tree/master/lua_oo","categories":[],"tags":[{"name":"lua","slug":"lua","permalink":"http://zzqboy.github.io/tags/lua/"}]},{"title":"ksum问题","slug":"ksum问题","date":"2018-06-09T15:28:00.000Z","updated":"2019-01-18T15:43:45.525Z","comments":true,"path":"2018/06/09/ksum问题/","link":"","permalink":"http://zzqboy.github.io/2018/06/09/ksum问题/","excerpt":"","text":"问题1234567Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] 解决方案此前还有2sum问题，那么可以把这个问题扩展为k-sum对于找出3个数，我们可以先固定一个数，在剩下的数里面去找到两个，那么复杂度就是n^2，这太高了，有没有可能不用暴力解决。答案是肯定的，因为最终的和是知道的，那么我们固定了一个数，就可以根据其他两个数来判断是如何移动，达到线性搜索。前提是排好序 同理 4sum可以固定两个数，再去找剩余的两个数… 代码","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://zzqboy.github.io/tags/algorithm/"}]},{"title":"erlang gb_tree平衡树做排行","slug":"erlang-gb-tree平衡树做排行","date":"2018-03-14T15:30:53.000Z","updated":"2019-01-18T15:42:56.444Z","comments":true,"path":"2018/03/14/erlang-gb-tree平衡树做排行/","link":"","permalink":"http://zzqboy.github.io/2018/03/14/erlang-gb-tree平衡树做排行/","excerpt":"","text":"介绍平衡树简称AVL，出名的有红黑树，这里介绍一下erlang中gb_tree的实现gb_tree的原理比红黑树简单，没有过多的旋转跳跃闭着眼，是一种叫AA树的结构（Arne Andersson’s General Balanced Trees），有兴趣看这篇论文：传送门 结构{Size, Tree}是整个结构体，Tree的定义又是{Key, Value, Smaller, Bigger} | nil初始化直接返回{0, nil} 插入123insert(Key, Val, &#123;S, T&#125;) when is_integer(S) -&gt; S1 = S+1, &#123;S1, insert_1(Key, Val, T, ?pow(S1, ?p))&#125;. % 给size+1，insert_1返回新的结构 insert_1又是如何找到要插入的位置，且做平衡的?1234567891011121314151617181920% 由于对称性，这里讲插入左子树的情况就行insert_1(Key, Value, &#123;Key1, V, Smaller, Bigger&#125;, S) when Key &lt; Key1 -&gt; % 要插入的key比目前节点的key小 case insert_1(Key, Value, Smaller, ?div2(S)) of % 递归，在目前节点的左子树继续查找，当Smaller为nil的时候返回下面两种情况 % T1 就是已经更新好的左子树 &#123;T1, H1, S1&#125; -&gt; T = &#123;Key1, V, T1, Bigger&#125;, &#123;H2, S2&#125; = count(Bigger), H = ?mul2(erlang:max(H1, H2)), %% 每层都会被调用一次 SS = S1 + S2 + 1, P = ?pow(SS, ?p), if H &gt; P -&gt; % 满足这个条件就重新平衡 balance(T, SS); true -&gt; &#123;T, H, SS&#125; end; T1 -&gt; &#123;Key1, V, T1, Bigger&#125; % 结果--节点和右子树均没改变，T1改变 end; 平衡也就是上面的balance(T, SS),这里什么时候会被执行呢？看一下下面代码123%% 是的insert_1的&#123;T1，H1， S1&#125;分支被执行insert_1(Key, Value, nil, S) when S =:= 0 -&gt; &#123;&#123;Key, Value, nil, nil&#125;, 1, 1&#125;; 看看官方的说明也就是说 13行的H&gt;P就是重新进行平衡的时候了，而平衡的操作也很简单，看下代码，就是按顺序填满一棵树123456789101112balance_list_1(L, S) when S &gt; 1 -&gt; Sm = S - 1, S2 = Sm div 2, S1 = Sm - S2, &#123;T1, [&#123;K, V&#125; | L1]&#125; = balance_list_1(L, S1), &#123;T2, L2&#125; = balance_list_1(L1, S2), T = &#123;K, V, T1, T2&#125;, &#123;T, L2&#125;;balance_list_1([&#123;Key, Val&#125; | L], 1) -&gt; &#123;&#123;Key, Val, nil, nil&#125;, L&#125;;balance_list_1(L, 0) -&gt; &#123;nil, L&#125;. 删除删除比插入是更简单了，找到对应的结点，然后从结点的右子树里找到一个最小的代替当前的点12345678910111213141516delete_1(Key, &#123;Key1, Value, Smaller, Larger&#125;) when Key &lt; Key1 -&gt; Smaller1 = delete_1(Key, Smaller), &#123;Key1, Value, Smaller1, Larger&#125;;delete_1(Key, &#123;Key1, Value, Smaller, Bigger&#125;) when Key &gt; Key1 -&gt; Bigger1 = delete_1(Key, Bigger), &#123;Key1, Value, Smaller, Bigger1&#125;;delete_1(_, &#123;_, _, Smaller, Larger&#125;) -&gt; merge(Smaller, Larger).merge(Smaller, nil) -&gt; Smaller;merge(nil, Larger) -&gt; Larger;merge(Smaller, Larger) -&gt; &#123;Key, Value, Larger1&#125; = take_smallest1(Larger), &#123;Key, Value, Smaller, Larger1&#125;. 可以看到整棵树没有旋转等复杂操作，但是仍是一个效率比lists高的二叉树 排行榜如果是上面实现的数据结构，那么排行榜是实时的，且各个操作效率比内置的List还快，我之前写的版本就是这个改的。只是有的地方需要改变一下，大概有下面几点 因为无法知道以后的需求，可以加入一个cmp函数自定义排序顺序查找前几名的时候，因为查找一个可以二分法，前几名同样也可以用二分法获取当某个榜上的玩家数据更新的时候，需要从树里删除再重新插入，这样才能保持有序其他的可以看看 https://cloud.tencent.com/developer/article/1006610","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://zzqboy.github.io/tags/algorithm/"}]}]}