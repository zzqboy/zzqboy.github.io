{"meta":{"title":"zzqboy","subtitle":null,"description":null,"author":"zzqboy","url":"http://zzqboy.github.io"},"pages":[{"title":"categories","date":"2019-03-23T03:22:03.000Z","updated":"2019-03-23T03:22:27.543Z","comments":true,"path":"categories/index.html","permalink":"http://zzqboy.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-03-23T03:23:20.000Z","updated":"2019-03-23T03:23:34.087Z","comments":true,"path":"about/index.html","permalink":"http://zzqboy.github.io/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-03-23T03:40:56.000Z","updated":"2019-03-23T03:42:25.479Z","comments":true,"path":"friends/index.html","permalink":"http://zzqboy.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-23T03:20:48.000Z","updated":"2019-03-23T03:21:34.592Z","comments":true,"path":"tags/index.html","permalink":"http://zzqboy.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"web的原理","slug":"web的原理","date":"2019-03-23T14:42:10.000Z","updated":"2019-03-23T15:39:48.871Z","comments":true,"path":"2019/03/23/web的原理/","link":"","permalink":"http://zzqboy.github.io/2019/03/23/web的原理/","excerpt":"介绍http协议可以说是最常用的一种网络协议，但是也很容易忽略了他的原理。还记得“在浏览器上打开一个网页请求，请你说出这背后的原理”这样的面试题吗？这一切在读《HTTP权威指南》后就可以了如指掌了。本文在简述原理后给出一个文中的栗子…","text":"介绍http协议可以说是最常用的一种网络协议，但是也很容易忽略了他的原理。还记得“在浏览器上打开一个网页请求，请你说出这背后的原理”这样的面试题吗？这一切在读《HTTP权威指南》后就可以了如指掌了。本文在简述原理后给出一个文中的栗子… 原理当我们发出一个get请求的时候，http server大概发生了下面几个步骤： 接受客户端请求 接受请求报文 处理请求 对资源的映射和访问 构建响应 发送响应 记录日志 这一切看来非常像游戏中一条协议的处理，下面详细讲这几个 请求http的请求的本质是tcp，自然会先建立tcp连接，那么server会在接受连接后，等待报文的到达。 报文解析报文的过程：由图可知，当数据没有接受完是不能进行解析报文的。 每行的CRLF和Content-length就是用来判断是否接受完 处理在解析报文后，就知道浏览器想让server干嘛了，就可以对应做出各种响应。(GET、POST、PUT、Delete、HEAD、Options) 响应报文通常包括:(主要还是看协议) Content-Type描述了是哪个MIME类型 Content-Length 主体内容 MIME的类型 不过也有可能是重定向的响应，响应码为3XX，不是最终的响应 发送server在发送完报文后，会关闭非持久的连接，对于持久连接是不会关闭的。 echo server文中有个perl的echo server，这里用python重现 1234567891011121314151617181920212223242526272829303132333435#coding:utf-8import socketimport tracebackdef star_server(): s_socket = socket.socket() s_socket.bind((\"127.0.0.1\", 80)) s_socket.listen(5) print \"echo server at 80\" conn, address = None, None while not conn: conn, address = s_socket.accept() recv_chunk = conn.recv(1024) recv_data = recv_chunk print \"------------------------------\" print recv_data print \"from\", address print \"------------------------------\" path = recv_data.split()[1] if path == \"/\": echo_content = raw_input(\"echo:\\n\") try: response = \"HTTP/1.1 200 OK\\r\\nConnection:close\\r\\nContent-type:text-plain\\r\\n\\r\\n\" response = response + echo_content conn.sendall(bytes(response)) except Exception, e: traceback.print_exc() conn.close() conn, address = None, Nonestar_server()","categories":[{"name":"技术","slug":"技术","permalink":"http://zzqboy.github.io/categories/技术/"}],"tags":[{"name":"http","slug":"http","permalink":"http://zzqboy.github.io/tags/http/"}]},{"title":"改善A星路径的猜想","slug":"改善A星路径的猜想","date":"2018-12-15T16:06:29.000Z","updated":"2019-03-23T03:31:15.340Z","comments":true,"path":"2018/12/16/改善A星路径的猜想/","link":"","permalink":"http://zzqboy.github.io/2018/12/16/改善A星路径的猜想/","excerpt":"问题如果周围都是可以寻路的点 并且是十字寻路，那么广度搜索和A*寻路的路径完全不一样 广度搜索都是一条笔直的线 A* 则是曲曲折折","text":"问题如果周围都是可以寻路的点 并且是十字寻路，那么广度搜索和A*寻路的路径完全不一样 广度搜索都是一条笔直的线 A* 则是曲曲折折 猜想在遍历一个点的4个方向的时候，如果最小分数有多个点，那么优先选择上次方向相同的点。如果只有一个点，那么只能强制选为下一个点，并且方向要改变。这样做后还是只能稍微改善下，不能完全解决，原因是分数小的点就是A星的核心，分数只要不一样就会一直改变方向 验证改善后： 结论如果一直强制一个方向也不是不可以，但会有下面两个问题： 强制不用A*算出的点，还能找到终点吗 这样会增加寻路复杂度感觉第一步就是强制设置为h函数的分数为0，那么永远在4个方向上选中一个点，但是这样就会退化成广度搜索了，毫无意义","categories":[{"name":"技术","slug":"技术","permalink":"http://zzqboy.github.io/categories/技术/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://zzqboy.github.io/tags/algorithm/"}]},{"title":"lua中面向对象","slug":"lua中面向对象","date":"2018-06-17T15:24:20.000Z","updated":"2019-03-23T03:31:12.124Z","comments":true,"path":"2018/06/17/lua中面向对象/","link":"","permalink":"http://zzqboy.github.io/2018/06/17/lua中面向对象/","excerpt":"pil实现方法要点：self语法糖、setmatetable元表、index方法提到了如何用__index方法来实现类和继承，让lua也具备面向对象的特性","text":"pil实现方法要点：self语法糖、setmatetable元表、index方法提到了如何用__index方法来实现类和继承，让lua也具备面向对象的特性 Account.lua123456789101112module(\"Account\", package.seeall)function Account:new(o) o = o or &#123;&#125; setmetatable(o, self) self.__index = self return oendfunction Account:deposit() print(\"account deposit\")end 这个机制的意思就是在创建一个新table的时候，把元类设为Account，在Account查找没有的方法12a = Account:new&#123;balance = 0&#125;a:deposit(100) -- 等价于 getmetatable(a).__index.deposit(a, 100) 实际上我们编写类的时候习惯把每个类划分为文件，如何用module结合上面的做法呢？这里写另外继承account的specialaccount类 SpecialAccount.lua12345678910module(\"SpecialAccount\", package.seeall)require(\"Account\")-- 继承自Account_G.SpecialAccount = Account:new()--定义基类没有的方法function SpecialAccount:getLimit() print(\"SpecialAccount getLimit\")end 注意上面的第5行代码，为什么不是书中的SpecialAccount = Account:new()？因为我们用module的时候已经默认引入了SpecialAccount，如果用这种做法，那么相当于增加了另外的变量，那么下面的代码就会报错 attempt to call method ‘new’ (a nil value) test.lua123456789require \"Account\"require \"SpecialAccount\"a = Account:new()a.deposit()s = SpecialAccount:new()s.deposit()s.getLimit() 原因在于module(“SpecialAccount”, package.seeall)相当于下面的代码12345local modname = \"SpecialAccount\"local M = &#123;&#125;_G[modname] = Mpackage.loaded[modname] = Msetfenv(1, M) 当SpecialAccount = Account:new()的时候，其实相当于1_G[\"SpecialAccount\"].SpecialAccount = Account:new() 这样在require “SpecialAccount”自然就找不到内嵌的new按照上面的写法就可以自然玩起面向对象了，附上代码https://github.com/zzqboy/misc/tree/master/lua_oo","categories":[{"name":"技术","slug":"技术","permalink":"http://zzqboy.github.io/categories/技术/"}],"tags":[{"name":"lua","slug":"lua","permalink":"http://zzqboy.github.io/tags/lua/"}]},{"title":"ksum问题","slug":"ksum问题","date":"2018-06-09T15:28:00.000Z","updated":"2019-03-23T03:31:03.716Z","comments":true,"path":"2018/06/09/ksum问题/","link":"","permalink":"http://zzqboy.github.io/2018/06/09/ksum问题/","excerpt":"","text":"问题1234567Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] 解决方案此前还有2sum问题，那么可以把这个问题扩展为k-sum对于找出3个数，我们可以先固定一个数，在剩下的数里面去找到两个，那么复杂度就是n^2，这太高了，有没有可能不用暴力解决。答案是肯定的，因为最终的和是知道的，那么我们固定了一个数，就可以根据其他两个数来判断是如何移动，达到线性搜索。前提是排好序 同理 4sum可以固定两个数，再去找剩余的两个数… 代码","categories":[{"name":"技术","slug":"技术","permalink":"http://zzqboy.github.io/categories/技术/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zzqboy.github.io/tags/leetcode/"}]},{"title":"erlang gb_tree平衡树做排行","slug":"erlang-gb-tree平衡树做排行","date":"2018-03-14T15:30:53.000Z","updated":"2019-03-23T03:31:09.036Z","comments":true,"path":"2018/03/14/erlang-gb-tree平衡树做排行/","link":"","permalink":"http://zzqboy.github.io/2018/03/14/erlang-gb-tree平衡树做排行/","excerpt":"介绍平衡树简称AVL，出名的有红黑树，这里介绍一下erlang中gb_tree的实现gb_tree的原理比红黑树简单，没有过多的旋转跳跃闭着眼，是一种叫AA树的结构（Arne Andersson’s General Balanced Trees），有兴趣看这篇论文：传送门","text":"介绍平衡树简称AVL，出名的有红黑树，这里介绍一下erlang中gb_tree的实现gb_tree的原理比红黑树简单，没有过多的旋转跳跃闭着眼，是一种叫AA树的结构（Arne Andersson’s General Balanced Trees），有兴趣看这篇论文：传送门 结构{Size, Tree}是整个结构体，Tree的定义又是{Key, Value, Smaller, Bigger} | nil初始化直接返回{0, nil} 插入123insert(Key, Val, &#123;S, T&#125;) when is_integer(S) -&gt; S1 = S+1, &#123;S1, insert_1(Key, Val, T, ?pow(S1, ?p))&#125;. % 给size+1，insert_1返回新的结构 insert_1又是如何找到要插入的位置，且做平衡的?1234567891011121314151617181920% 由于对称性，这里讲插入左子树的情况就行insert_1(Key, Value, &#123;Key1, V, Smaller, Bigger&#125;, S) when Key &lt; Key1 -&gt; % 要插入的key比目前节点的key小 case insert_1(Key, Value, Smaller, ?div2(S)) of % 递归，在目前节点的左子树继续查找，当Smaller为nil的时候返回下面两种情况 % T1 就是已经更新好的左子树 &#123;T1, H1, S1&#125; -&gt; T = &#123;Key1, V, T1, Bigger&#125;, &#123;H2, S2&#125; = count(Bigger), H = ?mul2(erlang:max(H1, H2)), %% 每层都会被调用一次 SS = S1 + S2 + 1, P = ?pow(SS, ?p), if H &gt; P -&gt; % 满足这个条件就重新平衡 balance(T, SS); true -&gt; &#123;T, H, SS&#125; end; T1 -&gt; &#123;Key1, V, T1, Bigger&#125; % 结果--节点和右子树均没改变，T1改变 end; 平衡也就是上面的balance(T, SS),这里什么时候会被执行呢？看一下下面代码123%% 是的insert_1的&#123;T1，H1， S1&#125;分支被执行insert_1(Key, Value, nil, S) when S =:= 0 -&gt; &#123;&#123;Key, Value, nil, nil&#125;, 1, 1&#125;; 看看官方的说明也就是说 13行的H&gt;P就是重新进行平衡的时候了，而平衡的操作也很简单，看下代码，就是按顺序填满一棵树123456789101112balance_list_1(L, S) when S &gt; 1 -&gt; Sm = S - 1, S2 = Sm div 2, S1 = Sm - S2, &#123;T1, [&#123;K, V&#125; | L1]&#125; = balance_list_1(L, S1), &#123;T2, L2&#125; = balance_list_1(L1, S2), T = &#123;K, V, T1, T2&#125;, &#123;T, L2&#125;;balance_list_1([&#123;Key, Val&#125; | L], 1) -&gt; &#123;&#123;Key, Val, nil, nil&#125;, L&#125;;balance_list_1(L, 0) -&gt; &#123;nil, L&#125;. 删除删除比插入是更简单了，找到对应的结点，然后从结点的右子树里找到一个最小的代替当前的点12345678910111213141516delete_1(Key, &#123;Key1, Value, Smaller, Larger&#125;) when Key &lt; Key1 -&gt; Smaller1 = delete_1(Key, Smaller), &#123;Key1, Value, Smaller1, Larger&#125;;delete_1(Key, &#123;Key1, Value, Smaller, Bigger&#125;) when Key &gt; Key1 -&gt; Bigger1 = delete_1(Key, Bigger), &#123;Key1, Value, Smaller, Bigger1&#125;;delete_1(_, &#123;_, _, Smaller, Larger&#125;) -&gt; merge(Smaller, Larger).merge(Smaller, nil) -&gt; Smaller;merge(nil, Larger) -&gt; Larger;merge(Smaller, Larger) -&gt; &#123;Key, Value, Larger1&#125; = take_smallest1(Larger), &#123;Key, Value, Smaller, Larger1&#125;. 可以看到整棵树没有旋转等复杂操作，但是仍是一个效率比lists高的二叉树 排行榜如果是上面实现的数据结构，那么排行榜是实时的，且各个操作效率比内置的List还快，我之前写的版本就是这个改的。只是有的地方需要改变一下，大概有下面几点 因为无法知道以后的需求，可以加入一个cmp函数自定义排序顺序查找前几名的时候，因为查找一个可以二分法，前几名同样也可以用二分法获取当某个榜上的玩家数据更新的时候，需要从树里删除再重新插入，这样才能保持有序其他的可以看看 https://cloud.tencent.com/developer/article/1006610","categories":[{"name":"技术","slug":"技术","permalink":"http://zzqboy.github.io/categories/技术/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://zzqboy.github.io/tags/algorithm/"}]}]}