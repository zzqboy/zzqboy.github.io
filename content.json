{"meta":{"title":"zzqboy","subtitle":null,"description":null,"author":"zzqboy","url":"http://zzqboy.github.io"},"pages":[{"title":"我是谁？","date":"2019-03-23T03:23:20.000Z","updated":"2019-07-02T13:37:15.009Z","comments":true,"path":"about/index.html","permalink":"http://zzqboy.github.io/about/index.html","excerpt":"","text":"介绍毕业于华师大，现在是一个游戏工程师(,,•﹏•,,) 爱好运动，电影，动漫 个人项目自己平时学习的一些代码，欢迎交流 《统计学习方法》的python实现这是大四实习时写的，实现了基本的数据挖掘模型。 欢迎做个朋友Email : ziquanzheng@foxmail.comQQ : 1163802968"},{"title":"categories","date":"2019-03-23T03:22:03.000Z","updated":"2019-03-23T03:22:27.543Z","comments":true,"path":"categories/index.html","permalink":"http://zzqboy.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-23T03:20:48.000Z","updated":"2019-03-23T03:21:34.592Z","comments":true,"path":"tags/index.html","permalink":"http://zzqboy.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"从源码了解Python的函数机制","slug":"从源码了解Python的函数机制","date":"2019-07-28T07:14:28.000Z","updated":"2019-07-28T07:25:34.744Z","comments":true,"path":"2019/07/28/从源码了解Python的函数机制/","link":"","permalink":"http://zzqboy.github.io/2019/07/28/从源码了解Python的函数机制/","excerpt":"","text":"前言python是一门动态语言，因此了解这部分的实现比其他的来的有意义的，可以帮助我们理解所谓的动态特性，以及函数热更等 结构 PyCodeObj PyFunObj pycodeobj是虚拟机在编译代码生成pyc的时候就确定了，而这里面可能有多个函数，虚拟机把函数也定义为一个对象pyfunobj，并且是在运行的时候才生成。 看看源码pyfunobj的组成：123456789101112131415161718typedef struct &#123; PyObject_HEAD PyObject *func_code; /* A code object */ PyObject *func_globals; /* A dictionary (other mappings won't do) */ PyObject *func_defaults; /* NULL or a tuple */ PyObject *func_closure; /* NULL or a tuple of cell objects */ PyObject *func_doc; /* The __doc__ attribute, can be anything */ PyObject *func_name; /* The __name__ attribute, a string object */ PyObject *func_dict; /* The __dict__ attribute, a dict or NULL */ PyObject *func_weakreflist; /* List of weak references */ PyObject *func_module; /* The __module__ attribute, can be anything */ /* Invariant: * func_closure contains the bindings for func_code-&gt;co_freevars, so * PyTuple_Size(func_closure) == PyCode_GetNumFree(func_code) * (func_closure may be NULL if PyCode_GetNumFree(func_code) == 0). */&#125; PyFunctionObject; 这两个是如何定义函数的，我们用下面的代码来查看：1234567891011121314151617# def f():# a = 2# print a# f()def test(): def f(): a = 2 print a f()import disprint dis.dis(test) 我们用compile和dis查看编译的pycodeobj和字节码12345678910 0 LOAD_CONST 1 3 MAKE_FUNCTION 0 6 STORE_FAST 0 (f)14 9 LOAD_FAST 0 (f) 12 CALL_FUNCTION 0 15 POP_TOP 16 LOAD_CONST 0 (None) 19 RETURN_VALUE 第10行代码也就是def f():，这里并没有a = 2;print a的字节码，也就是说函数内的字节码并不是在当前的pycodeobj里，而是在另外的pycodeobj 在用compile来查看注释部分的pycodeobj关系： 123co = compile(open('test.py').read(), 'test.py', 'exec')print co.co_consts[0]print co.co_consts[0].co_name 可以看到下面结果 说明f函数的实现是在嵌套的pycodeobj里面以上就是函数的定义和实现部分，接下来只剩f()函数调用的部分 调用来看看CALL_FUNCTIONpython是怎么执行的1234567891011121314151617181920212223call_function(PyObject ***pp_stack, int oparg)&#123; int na = oparg &amp; 0xff; int nk = (oparg&gt;&gt;8) &amp; 0xff; int n = na + 2 * nk; PyObject **pfunc = (*pp_stack) - n - 1; PyObject *func = *pfunc; PyObject *x, *w; if (PyCFunction_Check(func) &amp;&amp; nk == 0) &#123; ...... &#125; else &#123; ...... if (PyFunction_Check(func)) x = fast_function(func, pp_stack, n, na, nk); else x = do_call(func, pp_stack, na, nk);** ...... &#125; ...... &#125; return x;&#125; 再看看fast_function的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152static PyObject *fast_function(PyObject *func, PyObject ***pp_stack, int n, int na, int nk)&#123; PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func); PyObject *globals = PyFunction_GET_GLOBALS(func); PyObject *argdefs = PyFunction_GET_DEFAULTS(func); PyObject **d = NULL; int nd = 0; PCALL(PCALL_FUNCTION); PCALL(PCALL_FAST_FUNCTION); if (argdefs == NULL &amp;&amp; co-&gt;co_argcount == n &amp;&amp; nk==0 &amp;&amp; co-&gt;co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) &#123; PyFrameObject *f; PyObject *retval = NULL; PyThreadState *tstate = PyThreadState_GET(); PyObject **fastlocals, **stack; int i; PCALL(PCALL_FASTER_FUNCTION); assert(globals != NULL); /* XXX Perhaps we should create a specialized PyFrame_New() that doesn't take locals, but does take builtins without sanity checking them. */ assert(tstate != NULL); f = PyFrame_New(tstate, co, globals, NULL); if (f == NULL) return NULL; fastlocals = f-&gt;f_localsplus; stack = (*pp_stack) - n; for (i = 0; i &lt; n; i++) &#123; Py_INCREF(*stack); fastlocals[i] = *stack++; &#125; retval = PyEval_EvalFrameEx(f,0); ++tstate-&gt;recursion_depth; Py_DECREF(f); --tstate-&gt;recursion_depth; return retval; &#125; if (argdefs != NULL) &#123; d = &amp;PyTuple_GET_ITEM(argdefs, 0); nd = Py_SIZE(argdefs); &#125; return PyEval_EvalCodeEx(co, globals, (PyObject *)NULL, (*pp_stack)-n, na, (*pp_stack)-2*nk, nk, d, nd, PyFunction_GET_CLOSURE(func));&#125; 可以看到上面的过程就是创建新的PyFrameObj栈帧环境，拷贝global空间和传递PyCodeObj过去，然后又是新的执行字节码的操作，只不过这时候的字节码就是对应函数的","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://zzqboy.github.io/tags/python/"}]},{"title":"数独问题","slug":"数独解决","date":"2019-05-26T13:17:17.000Z","updated":"2019-07-28T07:19:22.643Z","comments":true,"path":"2019/05/26/数独解决/","link":"","permalink":"http://zzqboy.github.io/2019/05/26/数独解决/","excerpt":"","text":"问题求解9*9的速独的解决方法，之前已经有了一道判断速独有效性的题目，两道题有一定的关联性 1.用递归来填每个格子2.然后进行一次有效性的判断3.如果不是有效的那么这个格子需要填下一个数字，否则进行下个格子的填写。 因为这道题本身有一定的趣味，故在这里进行解速独的打印可以在 代码 34行进行调节速度观看过程 附图：","categories":[{"name":"技术","slug":"技术","permalink":"http://zzqboy.github.io/categories/技术/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zzqboy.github.io/tags/leetcode/"}]},{"title":"计算最长有效子串","slug":"计算最长有效子串","date":"2019-05-07T16:06:29.000Z","updated":"2019-07-28T07:19:14.124Z","comments":true,"path":"2019/05/08/计算最长有效子串/","link":"","permalink":"http://zzqboy.github.io/2019/05/08/计算最长有效子串/","excerpt":"","text":"问题判断在一条字符串里，合法的括号表示式有多长“(()” – 2“)()())” – 4 解法看了solution里的3种，这样的规律我感觉一般人是很难总结出来的。然后看了讨论区，发现有一种解法和自己一开始想的相近，这样的解法才比较符合一般人的思路。 那就是把有效的区域看做是被无效的切分开，我们要做的是找到被切开的各段的长度。 步骤：用一个栈来记录无法合并的索引然后根据索引来统计 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: int longestValidParentheses(string s) &#123; stack&lt;int&gt; c_s; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == '(') &#123; c_s.push(i); &#125; else &#123; if (!c_s.empty()) &#123; if (s[c_s.top()] == '(') &#123; c_s.pop(); &#125; else &#123; c_s.push(i); &#125; &#125; else &#123; c_s.push(i); &#125; &#125; &#125; if (c_s.empty()) &#123; return s.size(); &#125; int a = s.size(), b = 0; int max_ = 0; while (!c_s.empty()) &#123; b = c_s.top(); c_s.pop(); max_ = max(max_, a - b - 1); a = b; &#125; max_ = max(max_, a); return max_; &#125; &#125;;","categories":[{"name":"技术","slug":"技术","permalink":"http://zzqboy.github.io/categories/技术/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zzqboy.github.io/tags/leetcode/"}]},{"title":"浅析python排序算法timsort","slug":"浅析python排序算法timsort","date":"2019-04-09T14:41:04.000Z","updated":"2019-06-19T16:00:31.896Z","comments":true,"path":"2019/04/09/浅析python排序算法timsort/","link":"","permalink":"http://zzqboy.github.io/2019/04/09/浅析python排序算法timsort/","excerpt":"","text":"介绍timsort结合了插入排序和合并排序，主要是考虑到了，把每段有规律的数据分块，块的长度一开始计算好。然后有的数据块长度不足时使用插入补充。最后合并所有数据块。所以整个算法就是数据越规律，性能越高，整体性能甚至超过了快排： 过程定义 minrun 块长度 N 数组长度 确定minrunminrun根据输入数组的长度计算，因为块的长度影响最后合并的次数，如果块长度太短那么合并次数过多；太长那么要把每个块长度凑齐，插入排序的操作又太多。力求最后合并的次数是2的幂或略小于。123456789int GetMinrun(int n) &#123; int r = 0; while (n &gt;= 64) &#123; r |= n &amp; 1; n &gt;&gt;= 1; &#125; return n + r; &#125; 上面的公式说明：当N&lt;64的时候，minrun=N；当N&gt;=64；minrun与N最低6位有关 分块开始扫描，把有序的元素存入当前的run（块），如果这时候run长度小于minrun，那么直接添加后面缺的元素，知道长度达到minrun，这个时候后面的元素就不一定有序的，那么这个块需要进行插入排序。当然如果数据一直有序，那么run的长度就会比minrun大 ex:1 2 3 4 2 ….N = b10000 011111, minrun=5。run=[1, 2, 3, 4]，还是有序的。但是再加上2就不是有序，这个时候需要插入排序，变成[1, 2, 2, 3, 4] 合并依次把run压进栈，然后判断下面的两个条件是否满足： X &gt; Y + Z Y &gt; Z如果有一个不满足，那么找出X和Z中比较小的一个，和Y合并。直到满足了条件或者所有数据都排好序。（X、Y、Z表示run的size） (想象一个理想的例子：有一个128、64、32、16、8、4、2和2的运行（让我们暂时忘记运行大小≥minrun的要求）。在这种情况下，在最后两次运行不满足之前不会有任何合并，然后将执行七个完全平衡的合并。) 测试12345678910111213141516171819#coding:utf-8#现在项目排行榜有300人，假设服务器已经排好序，模拟下实时有个角色的数据变了，直接删除-添加-排序的耗时是多少import timeitimport randomrank_list = [i for i in range(300)]def resort(): index = value = random.randint(0, 299) rank_list.pop(index) rank_list.append(value) rank_list.sort() # print rank_listif __name__ == \"__main__\": print timeit.repeat(\"resort()\", setup=\"from __main__ import resort\", number=10000, repeat=3) print timeit.repeat(\"resort()\", setup=\"from __main__ import resort\", number=100000, repeat=3) print timeit.repeat(\"resort()\", setup=\"from __main__ import resort\", number=1000000, repeat=3) 结果：[0.07372325937786056, 0.07182481873564303, 0.07235884537346904][0.7830219300524532, 0.7451907132607314, 0.735450580565536][7.420490329467173, 7.352885764485594, 7.402370308503823] (这说明只要先排序了排行榜，那么1s的刷新可以达到10w次) 参考知乎上的问答一个比较简单的python实现本文的翻译原文参考","categories":[{"name":"技术","slug":"技术","permalink":"http://zzqboy.github.io/categories/技术/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://zzqboy.github.io/tags/algorithm/"},{"name":"python","slug":"python","permalink":"http://zzqboy.github.io/tags/python/"}]},{"title":"web的原理","slug":"web的原理","date":"2019-03-23T14:42:10.000Z","updated":"2019-04-07T09:51:31.901Z","comments":true,"path":"2019/03/23/web的原理/","link":"","permalink":"http://zzqboy.github.io/2019/03/23/web的原理/","excerpt":"介绍http协议可以说是最常用的一种网络协议，但是也很容易忽略了他的原理。还记得“在浏览器上打开一个网页请求，请你说出这背后的原理”这样的面试题吗？这一切在读《HTTP权威指南》后就可以了如指掌了。本文在简述原理后给出一个文中的栗子…","text":"介绍http协议可以说是最常用的一种网络协议，但是也很容易忽略了他的原理。还记得“在浏览器上打开一个网页请求，请你说出这背后的原理”这样的面试题吗？这一切在读《HTTP权威指南》后就可以了如指掌了。本文在简述原理后给出一个文中的栗子… 原理当我们发出一个get请求的时候，http server大概发生了下面几个步骤： 接受客户端请求 接受请求报文 处理请求 对资源的映射和访问 构建响应 发送响应 记录日志 这一切看来非常像游戏中一条协议的处理，下面详细讲这几个 请求http的请求的本质是tcp，自然会先建立tcp连接，那么server会在接受连接后，等待报文的到达。 报文解析报文的过程：由图可知，当数据没有接受完是不能进行解析报文的。 每行的CRLF和Content-length就是用来判断是否接受完 处理在解析报文后，就知道浏览器想让server干嘛了，就可以对应做出各种响应。(GET、POST、PUT、Delete、HEAD、Options) 响应报文通常包括:(主要还是看协议) Content-Type描述了是哪个MIME类型 Content-Length 主体内容 MIME的类型 不过也有可能是重定向的响应，响应码为3XX，不是最终的响应 发送server在发送完报文后，会关闭非持久的连接，对于持久连接是不会关闭的。 echo server文中有个perl的echo server，这里用python重现 1234567891011121314151617181920212223242526272829303132333435#coding:utf-8import socketimport tracebackdef star_server(): s_socket = socket.socket() s_socket.bind((\"127.0.0.1\", 80)) s_socket.listen(5) print \"echo server at 80\" conn, address = None, None while not conn: conn, address = s_socket.accept() recv_chunk = conn.recv(1024) recv_data = recv_chunk print \"------------------------------\" print recv_data print \"from\", address print \"------------------------------\" path = recv_data.split()[1] if path == \"/\": echo_content = raw_input(\"echo:\\n\") try: response = \"HTTP/1.1 200 OK\\r\\nConnection:close\\r\\nContent-type:text-plain\\r\\n\\r\\n\" response = response + echo_content conn.sendall(bytes(response)) except Exception, e: traceback.print_exc() conn.close() conn, address = None, Nonestar_server()","categories":[{"name":"技术","slug":"技术","permalink":"http://zzqboy.github.io/categories/技术/"}],"tags":[{"name":"http","slug":"http","permalink":"http://zzqboy.github.io/tags/http/"}]},{"title":"改善A星路径的猜想","slug":"改善A星路径的猜想","date":"2018-12-15T16:06:29.000Z","updated":"2019-04-20T09:00:19.942Z","comments":true,"path":"2018/12/16/改善A星路径的猜想/","link":"","permalink":"http://zzqboy.github.io/2018/12/16/改善A星路径的猜想/","excerpt":"问题如果周围都是可以寻路的点 并且是十字寻路，那么广度搜索和A*寻路的路径完全不一样 广度搜索都是一条笔直的线 A* 则是曲曲折折","text":"问题如果周围都是可以寻路的点 并且是十字寻路，那么广度搜索和A*寻路的路径完全不一样 广度搜索都是一条笔直的线 A* 则是曲曲折折 猜想在遍历一个点的4个方向的时候，如果最小分数有多个点，那么优先选择上次方向相同的点。如果只有一个点，那么只能强制选为下一个点，并且方向要改变。这样做后还是只能稍微改善下，不能完全解决，原因是分数小的点就是A星的核心，分数只要不一样就会一直改变方向 验证改善后： 结论如果一直强制一个方向也不是不可以，但会有下面两个问题： 强制不用A*算出的点，还能找到终点吗 这样会增加寻路复杂度感觉第一步就是强制设置为h函数的分数为0，那么永远在4个方向上选中一个点，但是这样就会退化成广度搜索了，毫无意义","categories":[{"name":"技术","slug":"技术","permalink":"http://zzqboy.github.io/categories/技术/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://zzqboy.github.io/tags/algorithm/"}]},{"title":"lua中面向对象","slug":"lua中面向对象","date":"2018-06-17T15:24:20.000Z","updated":"2019-03-23T03:31:12.124Z","comments":true,"path":"2018/06/17/lua中面向对象/","link":"","permalink":"http://zzqboy.github.io/2018/06/17/lua中面向对象/","excerpt":"pil实现方法要点：self语法糖、setmatetable元表、index方法提到了如何用__index方法来实现类和继承，让lua也具备面向对象的特性","text":"pil实现方法要点：self语法糖、setmatetable元表、index方法提到了如何用__index方法来实现类和继承，让lua也具备面向对象的特性 Account.lua123456789101112module(\"Account\", package.seeall)function Account:new(o) o = o or &#123;&#125; setmetatable(o, self) self.__index = self return oendfunction Account:deposit() print(\"account deposit\")end 这个机制的意思就是在创建一个新table的时候，把元类设为Account，在Account查找没有的方法12a = Account:new&#123;balance = 0&#125;a:deposit(100) -- 等价于 getmetatable(a).__index.deposit(a, 100) 实际上我们编写类的时候习惯把每个类划分为文件，如何用module结合上面的做法呢？这里写另外继承account的specialaccount类 SpecialAccount.lua12345678910module(\"SpecialAccount\", package.seeall)require(\"Account\")-- 继承自Account_G.SpecialAccount = Account:new()--定义基类没有的方法function SpecialAccount:getLimit() print(\"SpecialAccount getLimit\")end 注意上面的第5行代码，为什么不是书中的SpecialAccount = Account:new()？因为我们用module的时候已经默认引入了SpecialAccount，如果用这种做法，那么相当于增加了另外的变量，那么下面的代码就会报错 attempt to call method ‘new’ (a nil value) test.lua123456789require \"Account\"require \"SpecialAccount\"a = Account:new()a.deposit()s = SpecialAccount:new()s.deposit()s.getLimit() 原因在于module(“SpecialAccount”, package.seeall)相当于下面的代码12345local modname = \"SpecialAccount\"local M = &#123;&#125;_G[modname] = Mpackage.loaded[modname] = Msetfenv(1, M) 当SpecialAccount = Account:new()的时候，其实相当于1_G[\"SpecialAccount\"].SpecialAccount = Account:new() 这样在require “SpecialAccount”自然就找不到内嵌的new按照上面的写法就可以自然玩起面向对象了，附上代码https://github.com/zzqboy/misc/tree/master/lua_oo","categories":[{"name":"技术","slug":"技术","permalink":"http://zzqboy.github.io/categories/技术/"}],"tags":[{"name":"lua","slug":"lua","permalink":"http://zzqboy.github.io/tags/lua/"}]},{"title":"ksum问题","slug":"ksum问题","date":"2018-06-09T15:28:00.000Z","updated":"2019-03-23T03:31:03.716Z","comments":true,"path":"2018/06/09/ksum问题/","link":"","permalink":"http://zzqboy.github.io/2018/06/09/ksum问题/","excerpt":"","text":"问题1234567Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] 解决方案此前还有2sum问题，那么可以把这个问题扩展为k-sum对于找出3个数，我们可以先固定一个数，在剩下的数里面去找到两个，那么复杂度就是n^2，这太高了，有没有可能不用暴力解决。答案是肯定的，因为最终的和是知道的，那么我们固定了一个数，就可以根据其他两个数来判断是如何移动，达到线性搜索。前提是排好序 同理 4sum可以固定两个数，再去找剩余的两个数… 代码","categories":[{"name":"技术","slug":"技术","permalink":"http://zzqboy.github.io/categories/技术/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zzqboy.github.io/tags/leetcode/"}]}]}